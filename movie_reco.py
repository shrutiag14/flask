# -*- coding: utf-8 -*-
"""movie reco.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/shrutiag14/movie-recommendation-system/blob/master/movie_reco.ipynb
"""

import flask
import difflib
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

app = flask.Flask(__name__)

df = pd.read_csv("movie_dataset.csv")
df.head(3)

df.columns

features = ['keywords','genres','cast','director','runtime','spoken_languages']
for feature in features:
	df[feature] = df[feature].fillna('')

def combine_feature(row):
	try:
		return (row['keywords'] + ' ' +  row['genres'] + ' ' + row['cast'] + ' ' +  row['director'] + ' ' +  str(row['runtime']) + ' ' +  row['spoken_languages'])
	except:
		print("Error:",row)

df['combined_features'] = df.apply(combine_feature,axis = 1)
print(df['combined_features'].head())

cv = CountVectorizer()
count_matrix = cv.fit_transform(df['combined_features'])
cosine_sim = cosine_similarity(count_matrix)

def titlefromindex(index):
	return df[df['index'] == index].title.values[0]

def get_index_from_title(title):
	return df[df['title'] == title].index.values[0]

def recommend(movie):
    movie_index = get_index_from_title(movie)
    
    #Get a list of similar movies in descending order of similarity score
    similarmovies = list(enumerate(cosine_sim[movie_index]))
    sorted_similarmovies = sorted(similarmovies,key=lambda x:x[1],reverse=True)
    
    #Print titles of first count movies
    count = 0
    for movie in sorted_similarmovies:
        count += 1
        if count == 1:
            continue
        if count != 10:
            print(' '*8 + titlefromindex(movie[0]))
        else:
            break

@app.route('/', methods=['GET', 'POST'])
def main():
    if flask.request.method == 'GET':
        return(flask.render_template('index.html'))
            
    if flask.request.method == 'POST':
        m_name = flask.request.form['movie_name']
        m_name = m_name.title()
#        check = difflib.get_close_matches(m_name,all_titles,cutout=0.50,n=1)
        if m_name not in all_titles:
            return(flask.render_template('negative.html',name=m_name))
        else:
            result_final = get_recommendations(m_name)
            names = []
            dates = []
            for i in range(len(result_final)):
                names.append(result_final.iloc[i][0])
                dates.append(result_final.iloc[i][1])

            return flask.render_template('positive.html',movie_names=names,movie_date=dates,search_name=m_name)

if __name__ == '__main__':
    app.run()

